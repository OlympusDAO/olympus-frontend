/**
 * Generated by orval v6.23.0 ðŸº
 * Do not edit manually.
 * API for imxp4
 * Generated by encore
 * OpenAPI spec version: 1
 */
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";
import { useMutation, useQuery } from "@tanstack/react-query";
import { customHttpClient } from "src/views/Rewards/hooks/customHttpClient";
export type GETWorkersGetWorkerStatus200 = {
  running: boolean;
  tasks: string[];
};

export type GETUserUserUnits200 = {
  units: UserUserUnitsSummary;
};

export type GETUserUserUnitsParams = {
  chainId: LibChainId;
};

export type GETUserGetProfile200 = {
  address: string;
  createdAt: string;
  id: number;
};

export type GETUserUserHistory200 = {
  rewards: UserUserEpochRewardsSummary;
};

export type GETUserUserHistoryParams = {
  chainId: LibChainId;
};

export type GETSeasonsSeasonById200 = {
  season: SeasonsSeason;
};

export type GETSeasonsSeasonByIdParams = {
  chainId: LibChainId;
};

export type GETSeasonsLeaderboard200 = {
  asOfDate: string;
  chainId: LibChainId;
  comparisonDate: string;
  entries: SeasonsLeaderboardEntry[];
  total: number;
};

export type GETSeasonsLeaderboardParams = {
  chainId: LibChainId;
  limit?: number;
  offset?: number;
  daysAgo?: number;
  userAddress?: string;
};

export type GETSeasonsCurrent200 = {
  season: SeasonsSeasonWithStats;
};

export type GETSeasonsCurrentParams = {
  chainId: LibChainId;
};

export type GETSeasonsSeasons200 = {
  seasons: SeasonsSeason[];
};

export type GETSeasonsSeasonsParams = {
  chainId: LibChainId;
  sort?: SeasonsSortOrder;
};

export type GETReadyReady200 = {
  service: string;
  status: string;
  timestamp: string;
};

export type GETEpochsEpochRewardUsers200 = {
  epochId: number;
  pagination: EpochsPaginationInfo;
  rewardAssetId: number;
  rewardAssetSymbol: string;
  users: EpochsEpochRewardUser[];
};

export type GETEpochsEpochRewardUsersParams = {
  page?: number;
  limit?: number;
  sortOrder?: EpochsSortOrder;
};

export type GETEpochsEpochRewards200 = {
  epochId: number;
  rewards: EpochsEpochReward[];
};

export type GETEpochsCurrentEpoch200 = {
  endTimestamp: number;
  epochId: number;
  seasonId: number;
  seasonName: string;
  startTimestamp: number;
  totalUnits: string;
};

export type GETEpochsCurrentEpochParams = {
  chainId: LibChainId;
};

export type GETEpochsEpochsList200 = {
  epochs: EpochsEpoch[];
  pagination: EpochsPaginationInfo;
};

export type GETEpochsEpochsListParams = {
  chainId: LibChainId;
  page?: number;
  limit?: number;
  sortOrder?: EpochsSortOrder;
};

export type GETAuthVerify200 = {
  address: string;
  authenticated: boolean;
};

export type POSTAuthGetNonce200SiweMessage = {
  address: string;
  chainId: LibChainId;
  domain: string;
  expirationTime: string;
  issuedAt: string;
  nonce: string;
  uri: string;
  version: string;
};

export type POSTAuthGetNonce200 = {
  message: string;
  nonce: string;
  siweMessage?: POSTAuthGetNonce200SiweMessage;
};

export type POSTAuthGetNonceBody = {
  address: string;
  chainId?: LibChainId;
  domain?: string;
  uri?: string;
};

export type POSTAuthLogin200 = {
  address: string;
  expiresIn: string;
  token: string;
};

export type POSTAuthLoginBody = {
  address: string;
  message: string;
  signature: string;
};

export type GETAdminMultisigMembers200 = {
  chainId: LibChainId;
  delegates: AdminSafeDelegate[];
  owners: string[];
  safeAddress: string;
  threshold: number;
};

export type GETAdminMultisigMembersParams = {
  chainId: LibChainId;
};

export type GETAdminPendingEpochs200 = {
  chainId: LibChainId;
  epochs: AdminPendingEpoch[];
  safeAddress: string;
};

export type GETAdminPendingEpochsParams = {
  chainId: LibChainId;
};

export type POSTAdminSubmitEpochTransactionApi200 = {
  epochRewardsId: number;
  safeTxHash: string;
  safeUrl: string;
  success: boolean;
};

export type POSTAdminSubmitEpochTransactionApiBody = {
  safeTxHash: string;
  senderSignature: string;
};

export type POSTAdminPrepareEpochTransactionApi200 = {
  chainId: number;
  endTimestamp: number;
  epochRewardsId: number;
  merkleRoot: string;
  safeAddress: string;
  safeStatus: AdminProposalStatus;
  safeTxHash?: string;
  safeUrl?: string;
  status: AdminEpochRewardsStatus;
  success: boolean;
  transaction: AdminTransactionDetails;
};

/**
 * Error details
 */
export type APIErrorResponseDetails = { [key: string]: any };

export type APIErrorResponse = {
  /** Error code */
  code?: string;
  /** Error details */
  details?: APIErrorResponseDetails;
  /** Error message */
  message?: string;
};

export type UserUserUnitsSummary = {
  address: string;
  chainId: LibChainId;
  entries: UserUserDailyUnitsEntry[];
  totalUnits: string;
};

export type UserUserEpochRewardsEntry = {
  asset: string;
  endDate: number;
  epochId: number;
  merkleLeaf: string;
  merkleProof: string[];
  rewardAmount: string;
  rewardShare: string;
  startDate: number;
  totalUnits: string;
  updatedAt: string;
};

export type UserUserEpochRewardsSummary = {
  chainId: LibChainId;
  entries: UserUserEpochRewardsEntry[];
  totalRewardAmount: string;
  totalUnits: string;
  userAddress: string;
};

export type UserUserDailyUnitsEntryEpochId = number | boolean | null | null;

export type UserUserDailyUnitsEntryActionId = number | boolean | null | null;

export type UserUserDailyUnitsEntry = {
  actionId: UserUserDailyUnitsEntryActionId;
  calculatedAt: string;
  epochId: UserUserDailyUnitsEntryEpochId;
  units: string;
};

export type SeasonsSortOrder = (typeof SeasonsSortOrder)[keyof typeof SeasonsSortOrder];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SeasonsSortOrder = {
  ASC: "ASC",
  DESC: "DESC",
} as const;

export type SeasonsSeasonWithStatsEndDate = string | boolean | null | null;

export type SeasonsSeasonStatus = (typeof SeasonsSeasonStatus)[keyof typeof SeasonsSeasonStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SeasonsSeasonStatus = {
  active: "active",
  inactive: "inactive",
  completed: "completed",
} as const;

export type SeasonsSeasonWithStats = {
  chain_id: number;
  created_at: string;
  currentWeekTotalUnits: string;
  end_date: SeasonsSeasonWithStatsEndDate;
  epoch_length_days: number;
  id: number;
  name: string;
  start_date: string;
  status: SeasonsSeasonStatus;
  updated_at: string;
};

export type SeasonsSeasonEndDate = string | boolean | null | null;

export type SeasonsSeason = {
  chain_id: number;
  created_at: string;
  end_date: SeasonsSeasonEndDate;
  epoch_length_days: number;
  id: number;
  name: string;
  start_date: string;
  status: SeasonsSeasonStatus;
  updated_at: string;
};

export type SeasonsLeaderboardEntryPositionDirection =
  (typeof SeasonsLeaderboardEntryPositionDirection)[keyof typeof SeasonsLeaderboardEntryPositionDirection];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SeasonsLeaderboardEntryPositionDirection = {
  up: "up",
  down: "down",
  none: "none",
  new: "new",
} as const;

export type SeasonsLeaderboardEntry = {
  address: string;
  positionChange: number;
  positionDirection: SeasonsLeaderboardEntryPositionDirection;
  rank: number;
  totalUnits: string;
};

export type LibChainId = (typeof LibChainId)[keyof typeof LibChainId];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LibChainId = {
  NUMBER_1: 1,
  NUMBER_11155111: 11155111,
} as const;

export type EpochsSortOrder = (typeof EpochsSortOrder)[keyof typeof EpochsSortOrder];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EpochsSortOrder = {
  asc: "asc",
  desc: "desc",
} as const;

export type EpochsPaginationInfo = {
  limit: number;
  page: number;
  total: number;
  totalPages: number;
};

export type EpochsEpochRewardsStatus = (typeof EpochsEpochRewardsStatus)[keyof typeof EpochsEpochRewardsStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EpochsEpochRewardsStatus = {
  pending: "pending",
  calculated: "calculated",
  distributed: "distributed",
} as const;

export type EpochsEpochRewardUserMerkleProofs = string[] | boolean | null | null;

export type EpochsEpochRewardUserMerkleLeaf = string | boolean | null | null;

export type EpochsEpochRewardUser = {
  chainId: number;
  createdAt: string;
  epochId: number;
  id: number;
  merkleLeaf: EpochsEpochRewardUserMerkleLeaf;
  merkleProofs: EpochsEpochRewardUserMerkleProofs;
  rewardAmount: string;
  rewardAssetId: number;
  rewardAssetSymbol: string;
  rewardShare: string;
  units: string;
  updatedAt: string;
  userAddress: string;
  userId: number;
};

export type EpochsEpochRewardSafeUrl = string | boolean | null | null;

export type EpochsEpochRewardSafeTxHash = string | boolean | null | null;

export type EpochsEpochRewardMerkleRoot = string | boolean | null | null;

export type EpochsEpochReward = {
  createdAt: string;
  epochId: number;
  id: number;
  merkleRoot: EpochsEpochRewardMerkleRoot;
  rewardAmount: string;
  rewardAssetId: number;
  safeTxHash: EpochsEpochRewardSafeTxHash;
  safeUrl: EpochsEpochRewardSafeUrl;
  status: EpochsEpochRewardsStatus;
  tokenAddress: string;
  tokenDecimals: number;
  tokenSymbol: string;
  updatedAt: string;
};

export type EpochsEpoch = {
  createdAt: string;
  endTimestamp: number;
  id: number;
  seasonId: number;
  seasonName: string;
  startTimestamp: number;
  status: string;
  updatedAt: string;
};

export type AdminTransactionDetails = {
  data: string;
  operation: number;
  to: string;
  value: string;
};

export type AdminSafeDelegate = {
  delegate: string;
  delegator: string;
  expiryDate: string;
  label: string;
  safe: string;
};

export type AdminProposalStatus = (typeof AdminProposalStatus)[keyof typeof AdminProposalStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AdminProposalStatus = {
  CREATED: "CREATED",
  ALREADY_PENDING: "ALREADY_PENDING",
  ALREADY_EXECUTED: "ALREADY_EXECUTED",
} as const;

export type AdminEpochStatus = (typeof AdminEpochStatus)[keyof typeof AdminEpochStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AdminEpochStatus = {
  pending: "pending",
  calculated: "calculated",
  distributed: "distributed",
} as const;

export type AdminPendingEpoch = {
  assets: string[];
  endTimestamp: number;
  epochId: number;
  epochRewardsId: number;
  merkleRoot: string;
  safeTxHash?: string;
  safeUrl?: string;
  startTimestamp: number;
  status: AdminEpochStatus;
  totalRewardsDistributed: string;
  totalUnits: string;
  userCount: number;
};

export type AdminEpochRewardsStatus = (typeof AdminEpochRewardsStatus)[keyof typeof AdminEpochRewardsStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AdminEpochRewardsStatus = {
  pending: "pending",
  calculated: "calculated",
  distributed: "distributed",
} as const;

/**
 * @summary Serve Swagger UI using Encore's raw endpoint

 */
export const gETDocsSwaggerUI = (signal?: AbortSignal) => {
  return customHttpClient<void>({ url: `/`, method: "GET", signal });
};

export const getGETDocsSwaggerUIQueryKey = () => {
  return [`/`] as const;
};

export const getGETDocsSwaggerUIQueryOptions = <
  TData = Awaited<ReturnType<typeof gETDocsSwaggerUI>>,
  TError = APIErrorResponse,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof gETDocsSwaggerUI>>, TError, TData>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETDocsSwaggerUIQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETDocsSwaggerUI>>> = ({ signal }) => gETDocsSwaggerUI(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETDocsSwaggerUI>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETDocsSwaggerUIQueryResult = NonNullable<Awaited<ReturnType<typeof gETDocsSwaggerUI>>>;
export type GETDocsSwaggerUIQueryError = APIErrorResponse;

/**
 * @summary Serve Swagger UI using Encore's raw endpoint

 */
export const useGETDocsSwaggerUI = <
  TData = Awaited<ReturnType<typeof gETDocsSwaggerUI>>,
  TError = APIErrorResponse,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof gETDocsSwaggerUI>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETDocsSwaggerUIQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * This endpoint: 1. Authenticates the caller via JWT token 2. Looks up epoch rewards by ID to get chainId, distributorAddress, merkleRoot 3. Gets Safe address from server config for the chain 4. Verifies the caller is a multisig member (owner or delegate) 5. Checks for existing transactions with the same merkle root 6. Returns encoded transaction data for the frontend to sign

The frontend should use the returned transaction details to: - Create a Safe transaction using Safe Protocol Kit - Calculate the safeTxHash - Sign the transaction with the connected wallet - Call the submit endpoint with the signature

@param epochRewardsId - Primary key ID from epoch\_rewards table (path parameter) @returns PrepareTransactionResponse with transaction details, safeAddress, and chainId

@example POST /admin/epoch-rewards/42/prepare Headers: { "Authorization": "Bearer \<jwt\_token>" }

Response: { "success": true, "epochRewardsId": 42, "merkleRoot": "0x...", "endTimestamp": 1732406400, "status": "CREATED", "message": "Transaction data prepared...", "transaction": { "to": "0x...", "data": "0x...", "value": "0", "operation": 0 }, "safeAddress": "0x...", "chainId": 11155111 }

 * @summary Step 1: Prepare transaction data for frontend to sign

 */
export const pOSTAdminPrepareEpochTransactionApi = (epochRewardsId: number) => {
  return customHttpClient<POSTAdminPrepareEpochTransactionApi200>({
    url: `/admin/epoch-rewards/${epochRewardsId}/prepare`,
    method: "POST",
  });
};

export const getPOSTAdminPrepareEpochTransactionApiMutationOptions = <
  TError = APIErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof pOSTAdminPrepareEpochTransactionApi>>,
    TError,
    { epochRewardsId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof pOSTAdminPrepareEpochTransactionApi>>,
  TError,
  { epochRewardsId: number },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof pOSTAdminPrepareEpochTransactionApi>>,
    { epochRewardsId: number }
  > = props => {
    const { epochRewardsId } = props ?? {};

    return pOSTAdminPrepareEpochTransactionApi(epochRewardsId);
  };

  return { mutationFn, ...mutationOptions };
};

export type POSTAdminPrepareEpochTransactionApiMutationResult = NonNullable<
  Awaited<ReturnType<typeof pOSTAdminPrepareEpochTransactionApi>>
>;

export type POSTAdminPrepareEpochTransactionApiMutationError = APIErrorResponse;

/**
 * @summary Step 1: Prepare transaction data for frontend to sign

 */
export const usePOSTAdminPrepareEpochTransactionApi = <TError = APIErrorResponse, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof pOSTAdminPrepareEpochTransactionApi>>,
    TError,
    { epochRewardsId: number },
    TContext
  >;
}) => {
  const mutationOptions = getPOSTAdminPrepareEpochTransactionApiMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * This endpoint: 1. Authenticates the caller via JWT token 2. Looks up epoch rewards by ID to get chainId 3. Gets Safe address from server config for the chain 4. Validates the signature via Safe Transaction Service 5. Submits the signature to Safe Transaction Service

The frontend should: 1. First call /prepare to get transaction details, safeAddress, and chainId 2. Create a Safe transaction using Safe Protocol Kit 3. Sign the transaction with the connected wallet 4. Call this endpoint with the safeTxHash and signature

@param epochRewardsId - Primary key ID from epoch\_rewards table (path parameter) @param safeTxHash - Hash of the Safe transaction @param senderSignature - Signature from the caller's wallet @returns SubmitTransactionResponse with Safe transaction URL

@example POST /admin/epoch-rewards/42/submit Headers: { "Authorization": "Bearer \<jwt\_token>" } Body: { "safeTxHash": "0x...", "senderSignature": "0x..." }

Response: { "success": true, "epochRewardsId": 42, "safeTxHash": "0x...", "safeUrl": "[https://app.safe.global/](https://app.safe.global/)...", "message": "Transaction signature submitted..." }

 * @summary Step 2: Submit a signed transaction to Safe Transaction Service

 */
export const pOSTAdminSubmitEpochTransactionApi = (
  epochRewardsId: number,
  pOSTAdminSubmitEpochTransactionApiBody: POSTAdminSubmitEpochTransactionApiBody,
) => {
  return customHttpClient<POSTAdminSubmitEpochTransactionApi200>({
    url: `/admin/epoch-rewards/${epochRewardsId}/submit`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: pOSTAdminSubmitEpochTransactionApiBody,
  });
};

export const getPOSTAdminSubmitEpochTransactionApiMutationOptions = <
  TError = APIErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof pOSTAdminSubmitEpochTransactionApi>>,
    TError,
    { epochRewardsId: number; data: POSTAdminSubmitEpochTransactionApiBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof pOSTAdminSubmitEpochTransactionApi>>,
  TError,
  { epochRewardsId: number; data: POSTAdminSubmitEpochTransactionApiBody },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof pOSTAdminSubmitEpochTransactionApi>>,
    { epochRewardsId: number; data: POSTAdminSubmitEpochTransactionApiBody }
  > = props => {
    const { epochRewardsId, data } = props ?? {};

    return pOSTAdminSubmitEpochTransactionApi(epochRewardsId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type POSTAdminSubmitEpochTransactionApiMutationResult = NonNullable<
  Awaited<ReturnType<typeof pOSTAdminSubmitEpochTransactionApi>>
>;
export type POSTAdminSubmitEpochTransactionApiMutationBody = POSTAdminSubmitEpochTransactionApiBody;
export type POSTAdminSubmitEpochTransactionApiMutationError = APIErrorResponse;

/**
 * @summary Step 2: Submit a signed transaction to Safe Transaction Service

 */
export const usePOSTAdminSubmitEpochTransactionApi = <TError = APIErrorResponse, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof pOSTAdminSubmitEpochTransactionApi>>,
    TError,
    { epochRewardsId: number; data: POSTAdminSubmitEpochTransactionApiBody },
    TContext
  >;
}) => {
  const mutationOptions = getPOSTAdminSubmitEpochTransactionApiMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Returns a list of epochs with computed rewards and their Safe submission status. Each epoch includes: - Date range and merkle root - Total rewards and user counts - Submission status (NOT\_SUBMITTED, PENDING\_SIGNATURES, or EXECUTED)

Safe address is derived from server configuration based on chainId. Distributor address is fetched from database (reward\_assets table).

@param chainId - Blockchain chain ID (e.g., 11155111 for Sepolia, 1 for Mainnet) @returns PendingEpochsResponse with epochs array and safeAddress

@example GET /admin/epochs/pending?chainId=11155111

Response: { "epochs": \[ { "epochId": 1, "startTimestamp": 1732406400, "endTimestamp": 1732665599, "merkleRoot": "0x...", "totalRewardsDistributed": "1000000000000000000", "totalUnits": "5000", "userCount": 10, "assets": \["0x..."], "status": "NOT\_SUBMITTED" } ], "chainId": 11155111, "safeAddress": "0x..." }

 * @summary Get pending epochs requiring merkle root submission

 */
export const gETAdminPendingEpochs = (params: GETAdminPendingEpochsParams, signal?: AbortSignal) => {
  return customHttpClient<GETAdminPendingEpochs200>({ url: `/admin/epochs/pending`, method: "GET", params, signal });
};

export const getGETAdminPendingEpochsQueryKey = (params: GETAdminPendingEpochsParams) => {
  return [`/admin/epochs/pending`, ...(params ? [params] : [])] as const;
};

export const getGETAdminPendingEpochsQueryOptions = <
  TData = Awaited<ReturnType<typeof gETAdminPendingEpochs>>,
  TError = APIErrorResponse,
>(
  params: GETAdminPendingEpochsParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETAdminPendingEpochs>>, TError, TData> },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETAdminPendingEpochsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETAdminPendingEpochs>>> = ({ signal }) =>
    gETAdminPendingEpochs(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETAdminPendingEpochs>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETAdminPendingEpochsQueryResult = NonNullable<Awaited<ReturnType<typeof gETAdminPendingEpochs>>>;
export type GETAdminPendingEpochsQueryError = APIErrorResponse;

/**
 * @summary Get pending epochs requiring merkle root submission

 */
export const useGETAdminPendingEpochs = <
  TData = Awaited<ReturnType<typeof gETAdminPendingEpochs>>,
  TError = APIErrorResponse,
>(
  params: GETAdminPendingEpochsParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETAdminPendingEpochs>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETAdminPendingEpochsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Returns the list of owner addresses, delegates, and signature threshold for the server-configured Safe on the specified chain.

@param chainId - Blockchain chain ID (e.g., 11155111 for Sepolia, 1 for Mainnet) @returns MultisigMembersResponse with owners, delegates, and threshold

@example GET /admin/multisig/members?chainId=11155111

Response: { "safeAddress": "0x...", "owners": \["0x...", "0x...", "0x..."], "delegates": \[{ "delegate": "0x...", ... }], "threshold": 2, "chainId": 11155111 }

 * @summary Get multisig members (owners and delegates) for the configured Safe

 */
export const gETAdminMultisigMembers = (params: GETAdminMultisigMembersParams, signal?: AbortSignal) => {
  return customHttpClient<GETAdminMultisigMembers200>({
    url: `/admin/multisig/members`,
    method: "GET",
    params,
    signal,
  });
};

export const getGETAdminMultisigMembersQueryKey = (params: GETAdminMultisigMembersParams) => {
  return [`/admin/multisig/members`, ...(params ? [params] : [])] as const;
};

export const getGETAdminMultisigMembersQueryOptions = <
  TData = Awaited<ReturnType<typeof gETAdminMultisigMembers>>,
  TError = APIErrorResponse,
>(
  params: GETAdminMultisigMembersParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETAdminMultisigMembers>>, TError, TData> },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETAdminMultisigMembersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETAdminMultisigMembers>>> = ({ signal }) =>
    gETAdminMultisigMembers(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETAdminMultisigMembers>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETAdminMultisigMembersQueryResult = NonNullable<Awaited<ReturnType<typeof gETAdminMultisigMembers>>>;
export type GETAdminMultisigMembersQueryError = APIErrorResponse;

/**
 * @summary Get multisig members (owners and delegates) for the configured Safe

 */
export const useGETAdminMultisigMembers = <
  TData = Awaited<ReturnType<typeof gETAdminMultisigMembers>>,
  TError = APIErrorResponse,
>(
  params: GETAdminMultisigMembersParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETAdminMultisigMembers>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETAdminMultisigMembersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * This endpoint verifies the user's EIP-4361 (SIWE) signature and returns a JWT token that can be used for subsequent authenticated requests.

The token is valid for 7 days by default.

 * @summary Login endpoint - Exchange signature for JWT token

 */
export const pOSTAuthLogin = (pOSTAuthLoginBody: POSTAuthLoginBody) => {
  return customHttpClient<POSTAuthLogin200>({
    url: `/auth/login`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: pOSTAuthLoginBody,
  });
};

export const getPOSTAuthLoginMutationOptions = <TError = APIErrorResponse, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof pOSTAuthLogin>>,
    TError,
    { data: POSTAuthLoginBody },
    TContext
  >;
}): UseMutationOptions<Awaited<ReturnType<typeof pOSTAuthLogin>>, TError, { data: POSTAuthLoginBody }, TContext> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof pOSTAuthLogin>>,
    { data: POSTAuthLoginBody }
  > = props => {
    const { data } = props ?? {};

    return pOSTAuthLogin(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type POSTAuthLoginMutationResult = NonNullable<Awaited<ReturnType<typeof pOSTAuthLogin>>>;
export type POSTAuthLoginMutationBody = POSTAuthLoginBody;
export type POSTAuthLoginMutationError = APIErrorResponse;

/**
 * @summary Login endpoint - Exchange signature for JWT token

 */
export const usePOSTAuthLogin = <TError = APIErrorResponse, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof pOSTAuthLogin>>,
    TError,
    { data: POSTAuthLoginBody },
    TContext
  >;
}) => {
  const mutationOptions = getPOSTAuthLoginMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * This endpoint generates an EIP-4361 (Sign-In with Ethereum) compliant message that the user must sign with their wallet.

 * @summary Generate a nonce for the user to sign

 */
export const pOSTAuthGetNonce = (pOSTAuthGetNonceBody: POSTAuthGetNonceBody) => {
  return customHttpClient<POSTAuthGetNonce200>({
    url: `/auth/nonce`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: pOSTAuthGetNonceBody,
  });
};

export const getPOSTAuthGetNonceMutationOptions = <TError = APIErrorResponse, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof pOSTAuthGetNonce>>,
    TError,
    { data: POSTAuthGetNonceBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof pOSTAuthGetNonce>>,
  TError,
  { data: POSTAuthGetNonceBody },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof pOSTAuthGetNonce>>,
    { data: POSTAuthGetNonceBody }
  > = props => {
    const { data } = props ?? {};

    return pOSTAuthGetNonce(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type POSTAuthGetNonceMutationResult = NonNullable<Awaited<ReturnType<typeof pOSTAuthGetNonce>>>;
export type POSTAuthGetNonceMutationBody = POSTAuthGetNonceBody;
export type POSTAuthGetNonceMutationError = APIErrorResponse;

/**
 * @summary Generate a nonce for the user to sign

 */
export const usePOSTAuthGetNonce = <TError = APIErrorResponse, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof pOSTAuthGetNonce>>,
    TError,
    { data: POSTAuthGetNonceBody },
    TContext
  >;
}) => {
  const mutationOptions = getPOSTAuthGetNonceMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * This is a protected endpoint that requires authentication. It demonstrates how to use getAuthData() to access user data.

 * @summary Verify the user's authentication

 */
export const gETAuthVerify = (signal?: AbortSignal) => {
  return customHttpClient<GETAuthVerify200>({ url: `/auth/verify`, method: "GET", signal });
};

export const getGETAuthVerifyQueryKey = () => {
  return [`/auth/verify`] as const;
};

export const getGETAuthVerifyQueryOptions = <
  TData = Awaited<ReturnType<typeof gETAuthVerify>>,
  TError = APIErrorResponse,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof gETAuthVerify>>, TError, TData>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETAuthVerifyQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETAuthVerify>>> = ({ signal }) => gETAuthVerify(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETAuthVerify>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETAuthVerifyQueryResult = NonNullable<Awaited<ReturnType<typeof gETAuthVerify>>>;
export type GETAuthVerifyQueryError = APIErrorResponse;

/**
 * @summary Verify the user's authentication

 */
export const useGETAuthVerify = <
  TData = Awaited<ReturnType<typeof gETAuthVerify>>,
  TError = APIErrorResponse,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof gETAuthVerify>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETAuthVerifyQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Returns a paginated list of epochs with their details and pagination info. Epochs are filtered by chain\_id (via their season) and can be sorted by start\_date in ascending or descending order.

@param chainId - Blockchain chain ID (e.g., 11155111 for Sepolia, 1 for Mainnet) @param page - Page number (default: 1) @param limit - Items per page (default: 20, max: 100) @param sortOrder - Sort order by start\_date: 'asc' or 'desc' (default: 'desc') @returns EpochsListResponse with epochs array and pagination info

@example GET /epochs?chainId=11155111&page=1&limit=10&sortOrder=desc

Response: { "epochs": \[ { "id": 1, "seasonId": 1, "seasonName": "Season 1", "startTimestamp": 1732406400, "endTimestamp": 1732665599, "status": "completed", "createdAt": "2024-11-24 00:00:00", "updatedAt": "2024-11-24 00:00:00" } ], "pagination": { "page": 1, "limit": 10, "total": 25, "totalPages": 3 } }

 * @summary Get paginated list of epochs

 */
export const gETEpochsEpochsList = (params: GETEpochsEpochsListParams, signal?: AbortSignal) => {
  return customHttpClient<GETEpochsEpochsList200>({ url: `/epochs`, method: "GET", params, signal });
};

export const getGETEpochsEpochsListQueryKey = (params: GETEpochsEpochsListParams) => {
  return [`/epochs`, ...(params ? [params] : [])] as const;
};

export const getGETEpochsEpochsListQueryOptions = <
  TData = Awaited<ReturnType<typeof gETEpochsEpochsList>>,
  TError = APIErrorResponse,
>(
  params: GETEpochsEpochsListParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETEpochsEpochsList>>, TError, TData> },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETEpochsEpochsListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETEpochsEpochsList>>> = ({ signal }) =>
    gETEpochsEpochsList(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETEpochsEpochsList>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETEpochsEpochsListQueryResult = NonNullable<Awaited<ReturnType<typeof gETEpochsEpochsList>>>;
export type GETEpochsEpochsListQueryError = APIErrorResponse;

/**
 * @summary Get paginated list of epochs

 */
export const useGETEpochsEpochsList = <
  TData = Awaited<ReturnType<typeof gETEpochsEpochsList>>,
  TError = APIErrorResponse,
>(
  params: GETEpochsEpochsListParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETEpochsEpochsList>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETEpochsEpochsListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Returns the current epoch boundaries and accumulated units for the ongoing epoch. The epoch boundaries are calculated from the active season's configuration.

@param chainId - Blockchain chain ID (e.g., 11155111 for Sepolia) @returns Current epoch details including timestamps, season info, and accumulated units

@example GET /epochs/current?chainId=11155111

Response: { "epochId": 3, "startTimestamp": 1733702400, "endTimestamp": 1734307199, "seasonId": 1, "rewardsPercent": 50, "totalUnits": "1500000" }

 * @summary Get the current ongoing epoch details

 */
export const gETEpochsCurrentEpoch = (params: GETEpochsCurrentEpochParams, signal?: AbortSignal) => {
  return customHttpClient<GETEpochsCurrentEpoch200>({ url: `/epochs/current`, method: "GET", params, signal });
};

export const getGETEpochsCurrentEpochQueryKey = (params: GETEpochsCurrentEpochParams) => {
  return [`/epochs/current`, ...(params ? [params] : [])] as const;
};

export const getGETEpochsCurrentEpochQueryOptions = <
  TData = Awaited<ReturnType<typeof gETEpochsCurrentEpoch>>,
  TError = APIErrorResponse,
>(
  params: GETEpochsCurrentEpochParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETEpochsCurrentEpoch>>, TError, TData> },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETEpochsCurrentEpochQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETEpochsCurrentEpoch>>> = ({ signal }) =>
    gETEpochsCurrentEpoch(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETEpochsCurrentEpoch>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETEpochsCurrentEpochQueryResult = NonNullable<Awaited<ReturnType<typeof gETEpochsCurrentEpoch>>>;
export type GETEpochsCurrentEpochQueryError = APIErrorResponse;

/**
 * @summary Get the current ongoing epoch details

 */
export const useGETEpochsCurrentEpoch = <
  TData = Awaited<ReturnType<typeof gETEpochsCurrentEpoch>>,
  TError = APIErrorResponse,
>(
  params: GETEpochsCurrentEpochParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETEpochsCurrentEpoch>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETEpochsCurrentEpochQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Returns a list of rewards for the specified epoch, including token details and distribution status.

@param epochId - The epoch ID to fetch rewards for @returns EpochRewardsResponse with rewards array

@example GET /epochs/1/rewards

Response: { "epochId": 1, "rewards": \[ { "id": 1, "epochId": 1, "rewardAssetId": 1, "tokenAddress": "0xDd668BdDb4241F4fAFBB0BC0d75b49EbEE88B4FC", "tokenSymbol": "USDS", "tokenDecimals": 18, "rewardAmount": "1000000000000000000", "merkleRoot": "0x...", "status": "calculated", "safeTxHash": null, "safeUrl": null, "createdAt": "2024-11-24 00:00:00", "updatedAt": "2024-11-24 00:00:00" } ] }

 * @summary Get rewards for a specific epoch

 */
export const gETEpochsEpochRewards = (epochId: number, signal?: AbortSignal) => {
  return customHttpClient<GETEpochsEpochRewards200>({ url: `/epochs/${epochId}/rewards`, method: "GET", signal });
};

export const getGETEpochsEpochRewardsQueryKey = (epochId: number) => {
  return [`/epochs/${epochId}/rewards`] as const;
};

export const getGETEpochsEpochRewardsQueryOptions = <
  TData = Awaited<ReturnType<typeof gETEpochsEpochRewards>>,
  TError = APIErrorResponse,
>(
  epochId: number,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETEpochsEpochRewards>>, TError, TData> },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETEpochsEpochRewardsQueryKey(epochId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETEpochsEpochRewards>>> = ({ signal }) =>
    gETEpochsEpochRewards(epochId, signal);

  return { queryKey, queryFn, enabled: !!epochId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETEpochsEpochRewards>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETEpochsEpochRewardsQueryResult = NonNullable<Awaited<ReturnType<typeof gETEpochsEpochRewards>>>;
export type GETEpochsEpochRewardsQueryError = APIErrorResponse;

/**
 * @summary Get rewards for a specific epoch

 */
export const useGETEpochsEpochRewards = <
  TData = Awaited<ReturnType<typeof gETEpochsEpochRewards>>,
  TError = APIErrorResponse,
>(
  epochId: number,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETEpochsEpochRewards>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETEpochsEpochRewardsQueryOptions(epochId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Returns a paginated list of user rewards sorted by reward\_amount. Default sort order is descending (highest rewards first).

@param epochId - The epoch ID @param rewardAssetId - The reward asset ID @param page - Page number (default: 1) @param limit - Items per page (default: 20, max: 100) @param sortOrder - Sort order by reward\_amount: 'asc' or 'desc' (default: 'desc') @returns EpochRewardUsersResponse with users array and pagination info

@example GET /epochs/1/rewards/1/users?page=1&limit=10&sortOrder=desc

Response: { "epochId": 1, "rewardAssetId": 1, "rewardAssetSymbol": "USDS", "users": \[ { "id": 1, "userId": 123, "userAddress": "0x1234...5678", "epochId": 1, "rewardAssetId": 1, "rewardAssetSymbol": "USDS", "chainId": 11155111, "units": "1000000", "rewardAmount": "500000000000000000", "rewardShare": "0.05", "merkleLeaf": "0x...", "merkleProofs": \["0x...", "0x..."], "createdAt": "2024-11-24 00:00:00", "updatedAt": "2024-11-24 00:00:00" } ], "pagination": { "page": 1, "limit": 10, "total": 100, "totalPages": 10 } }

 * @summary Get paginated user rewards for a specific epoch and reward asset

 */
export const gETEpochsEpochRewardUsers = (
  epochId: number,
  rewardAssetId: number,
  params?: GETEpochsEpochRewardUsersParams,
  signal?: AbortSignal,
) => {
  return customHttpClient<GETEpochsEpochRewardUsers200>({
    url: `/epochs/${epochId}/rewards/${rewardAssetId}/users`,
    method: "GET",
    params,
    signal,
  });
};

export const getGETEpochsEpochRewardUsersQueryKey = (
  epochId: number,
  rewardAssetId: number,
  params?: GETEpochsEpochRewardUsersParams,
) => {
  return [`/epochs/${epochId}/rewards/${rewardAssetId}/users`, ...(params ? [params] : [])] as const;
};

export const getGETEpochsEpochRewardUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof gETEpochsEpochRewardUsers>>,
  TError = APIErrorResponse,
>(
  epochId: number,
  rewardAssetId: number,
  params?: GETEpochsEpochRewardUsersParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETEpochsEpochRewardUsers>>, TError, TData> },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETEpochsEpochRewardUsersQueryKey(epochId, rewardAssetId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETEpochsEpochRewardUsers>>> = ({ signal }) =>
    gETEpochsEpochRewardUsers(epochId, rewardAssetId, params, signal);

  return { queryKey, queryFn, enabled: !!(epochId && rewardAssetId), ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETEpochsEpochRewardUsers>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETEpochsEpochRewardUsersQueryResult = NonNullable<Awaited<ReturnType<typeof gETEpochsEpochRewardUsers>>>;
export type GETEpochsEpochRewardUsersQueryError = APIErrorResponse;

/**
 * @summary Get paginated user rewards for a specific epoch and reward asset

 */
export const useGETEpochsEpochRewardUsers = <
  TData = Awaited<ReturnType<typeof gETEpochsEpochRewardUsers>>,
  TError = APIErrorResponse,
>(
  epochId: number,
  rewardAssetId: number,
  params?: GETEpochsEpochRewardUsersParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETEpochsEpochRewardUsers>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETEpochsEpochRewardUsersQueryOptions(epochId, rewardAssetId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary JSON endpoint for the OpenAPI spec

 */
export const gETDocsOpenapiJson = (signal?: AbortSignal) => {
  return customHttpClient<void>({ url: `/openapi.json`, method: "GET", signal });
};

export const getGETDocsOpenapiJsonQueryKey = () => {
  return [`/openapi.json`] as const;
};

export const getGETDocsOpenapiJsonQueryOptions = <
  TData = Awaited<ReturnType<typeof gETDocsOpenapiJson>>,
  TError = APIErrorResponse,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof gETDocsOpenapiJson>>, TError, TData>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETDocsOpenapiJsonQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETDocsOpenapiJson>>> = ({ signal }) =>
    gETDocsOpenapiJson(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETDocsOpenapiJson>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETDocsOpenapiJsonQueryResult = NonNullable<Awaited<ReturnType<typeof gETDocsOpenapiJson>>>;
export type GETDocsOpenapiJsonQueryError = APIErrorResponse;

/**
 * @summary JSON endpoint for the OpenAPI spec

 */
export const useGETDocsOpenapiJson = <
  TData = Awaited<ReturnType<typeof gETDocsOpenapiJson>>,
  TError = APIErrorResponse,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof gETDocsOpenapiJson>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETDocsOpenapiJsonQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const gETReadyReady = (signal?: AbortSignal) => {
  return customHttpClient<GETReadyReady200>({ url: `/ready`, method: "GET", signal });
};

export const getGETReadyReadyQueryKey = () => {
  return [`/ready`] as const;
};

export const getGETReadyReadyQueryOptions = <
  TData = Awaited<ReturnType<typeof gETReadyReady>>,
  TError = APIErrorResponse,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof gETReadyReady>>, TError, TData>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETReadyReadyQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETReadyReady>>> = ({ signal }) => gETReadyReady(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETReadyReady>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETReadyReadyQueryResult = NonNullable<Awaited<ReturnType<typeof gETReadyReady>>>;
export type GETReadyReadyQueryError = APIErrorResponse;

export const useGETReadyReady = <
  TData = Awaited<ReturnType<typeof gETReadyReady>>,
  TError = APIErrorResponse,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof gETReadyReady>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETReadyReadyQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @param chainId - The blockchain chain ID (e.g., 11155111) @param sort - Sort order by season ID (default: 'asc') @returns List of all seasons for the chain

 * @summary Get all seasons for a specific chain

 */
export const gETSeasonsSeasons = (params: GETSeasonsSeasonsParams, signal?: AbortSignal) => {
  return customHttpClient<GETSeasonsSeasons200>({ url: `/seasons`, method: "GET", params, signal });
};

export const getGETSeasonsSeasonsQueryKey = (params: GETSeasonsSeasonsParams) => {
  return [`/seasons`, ...(params ? [params] : [])] as const;
};

export const getGETSeasonsSeasonsQueryOptions = <
  TData = Awaited<ReturnType<typeof gETSeasonsSeasons>>,
  TError = APIErrorResponse,
>(
  params: GETSeasonsSeasonsParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETSeasonsSeasons>>, TError, TData> },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETSeasonsSeasonsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETSeasonsSeasons>>> = ({ signal }) =>
    gETSeasonsSeasons(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETSeasonsSeasons>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETSeasonsSeasonsQueryResult = NonNullable<Awaited<ReturnType<typeof gETSeasonsSeasons>>>;
export type GETSeasonsSeasonsQueryError = APIErrorResponse;

/**
 * @summary Get all seasons for a specific chain

 */
export const useGETSeasonsSeasons = <TData = Awaited<ReturnType<typeof gETSeasonsSeasons>>, TError = APIErrorResponse>(
  params: GETSeasonsSeasonsParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETSeasonsSeasons>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETSeasonsSeasonsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @param chainId - The blockchain chain ID (e.g., 11155111) @returns The current season with its configuration and current week total units

 * @summary Get the current season for a specific chain

 */
export const gETSeasonsCurrent = (params: GETSeasonsCurrentParams, signal?: AbortSignal) => {
  return customHttpClient<GETSeasonsCurrent200>({ url: `/seasons/current`, method: "GET", params, signal });
};

export const getGETSeasonsCurrentQueryKey = (params: GETSeasonsCurrentParams) => {
  return [`/seasons/current`, ...(params ? [params] : [])] as const;
};

export const getGETSeasonsCurrentQueryOptions = <
  TData = Awaited<ReturnType<typeof gETSeasonsCurrent>>,
  TError = APIErrorResponse,
>(
  params: GETSeasonsCurrentParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETSeasonsCurrent>>, TError, TData> },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETSeasonsCurrentQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETSeasonsCurrent>>> = ({ signal }) =>
    gETSeasonsCurrent(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETSeasonsCurrent>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETSeasonsCurrentQueryResult = NonNullable<Awaited<ReturnType<typeof gETSeasonsCurrent>>>;
export type GETSeasonsCurrentQueryError = APIErrorResponse;

/**
 * @summary Get the current season for a specific chain

 */
export const useGETSeasonsCurrent = <TData = Awaited<ReturnType<typeof gETSeasonsCurrent>>, TError = APIErrorResponse>(
  params: GETSeasonsCurrentParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETSeasonsCurrent>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETSeasonsCurrentQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const gETSeasonsLeaderboard = (params: GETSeasonsLeaderboardParams, signal?: AbortSignal) => {
  return customHttpClient<GETSeasonsLeaderboard200>({ url: `/seasons/leaderboard`, method: "GET", params, signal });
};

export const getGETSeasonsLeaderboardQueryKey = (params: GETSeasonsLeaderboardParams) => {
  return [`/seasons/leaderboard`, ...(params ? [params] : [])] as const;
};

export const getGETSeasonsLeaderboardQueryOptions = <
  TData = Awaited<ReturnType<typeof gETSeasonsLeaderboard>>,
  TError = APIErrorResponse,
>(
  params: GETSeasonsLeaderboardParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETSeasonsLeaderboard>>, TError, TData> },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETSeasonsLeaderboardQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETSeasonsLeaderboard>>> = ({ signal }) =>
    gETSeasonsLeaderboard(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETSeasonsLeaderboard>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETSeasonsLeaderboardQueryResult = NonNullable<Awaited<ReturnType<typeof gETSeasonsLeaderboard>>>;
export type GETSeasonsLeaderboardQueryError = APIErrorResponse;

export const useGETSeasonsLeaderboard = <
  TData = Awaited<ReturnType<typeof gETSeasonsLeaderboard>>,
  TError = APIErrorResponse,
>(
  params: GETSeasonsLeaderboardParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETSeasonsLeaderboard>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETSeasonsLeaderboardQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @param id - The season ID @param chainId - The blockchain chain ID (e.g., 11155111) @returns The season object

 * @summary Get a season by ID for a specific chain

 */
export const gETSeasonsSeasonById = (id: number, params: GETSeasonsSeasonByIdParams, signal?: AbortSignal) => {
  return customHttpClient<GETSeasonsSeasonById200>({ url: `/seasons/${id}`, method: "GET", params, signal });
};

export const getGETSeasonsSeasonByIdQueryKey = (id: number, params: GETSeasonsSeasonByIdParams) => {
  return [`/seasons/${id}`, ...(params ? [params] : [])] as const;
};

export const getGETSeasonsSeasonByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof gETSeasonsSeasonById>>,
  TError = APIErrorResponse,
>(
  id: number,
  params: GETSeasonsSeasonByIdParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETSeasonsSeasonById>>, TError, TData> },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETSeasonsSeasonByIdQueryKey(id, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETSeasonsSeasonById>>> = ({ signal }) =>
    gETSeasonsSeasonById(id, params, signal);

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETSeasonsSeasonById>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETSeasonsSeasonByIdQueryResult = NonNullable<Awaited<ReturnType<typeof gETSeasonsSeasonById>>>;
export type GETSeasonsSeasonByIdQueryError = APIErrorResponse;

/**
 * @summary Get a season by ID for a specific chain

 */
export const useGETSeasonsSeasonById = <
  TData = Awaited<ReturnType<typeof gETSeasonsSeasonById>>,
  TError = APIErrorResponse,
>(
  id: number,
  params: GETSeasonsSeasonByIdParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETSeasonsSeasonById>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETSeasonsSeasonByIdQueryOptions(id, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const gETUserUserHistory = (address: string, params: GETUserUserHistoryParams, signal?: AbortSignal) => {
  return customHttpClient<GETUserUserHistory200>({ url: `/user/history/${address}`, method: "GET", params, signal });
};

export const getGETUserUserHistoryQueryKey = (address: string, params: GETUserUserHistoryParams) => {
  return [`/user/history/${address}`, ...(params ? [params] : [])] as const;
};

export const getGETUserUserHistoryQueryOptions = <
  TData = Awaited<ReturnType<typeof gETUserUserHistory>>,
  TError = APIErrorResponse,
>(
  address: string,
  params: GETUserUserHistoryParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETUserUserHistory>>, TError, TData> },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETUserUserHistoryQueryKey(address, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETUserUserHistory>>> = ({ signal }) =>
    gETUserUserHistory(address, params, signal);

  return { queryKey, queryFn, enabled: !!address, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETUserUserHistory>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETUserUserHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof gETUserUserHistory>>>;
export type GETUserUserHistoryQueryError = APIErrorResponse;

export const useGETUserUserHistory = <
  TData = Awaited<ReturnType<typeof gETUserUserHistory>>,
  TError = APIErrorResponse,
>(
  address: string,
  params: GETUserUserHistoryParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETUserUserHistory>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETUserUserHistoryQueryOptions(address, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * This is a protected endpoint that returns the current user's profile.

 * @summary Get the authenticated user's profile

 */
export const gETUserGetProfile = (signal?: AbortSignal) => {
  return customHttpClient<GETUserGetProfile200>({ url: `/user/profile`, method: "GET", signal });
};

export const getGETUserGetProfileQueryKey = () => {
  return [`/user/profile`] as const;
};

export const getGETUserGetProfileQueryOptions = <
  TData = Awaited<ReturnType<typeof gETUserGetProfile>>,
  TError = APIErrorResponse,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof gETUserGetProfile>>, TError, TData>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETUserGetProfileQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETUserGetProfile>>> = ({ signal }) =>
    gETUserGetProfile(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETUserGetProfile>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETUserGetProfileQueryResult = NonNullable<Awaited<ReturnType<typeof gETUserGetProfile>>>;
export type GETUserGetProfileQueryError = APIErrorResponse;

/**
 * @summary Get the authenticated user's profile

 */
export const useGETUserGetProfile = <
  TData = Awaited<ReturnType<typeof gETUserGetProfile>>,
  TError = APIErrorResponse,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof gETUserGetProfile>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETUserGetProfileQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const gETUserUserUnits = (address: string, params: GETUserUserUnitsParams, signal?: AbortSignal) => {
  return customHttpClient<GETUserUserUnits200>({ url: `/user/units/${address}`, method: "GET", params, signal });
};

export const getGETUserUserUnitsQueryKey = (address: string, params: GETUserUserUnitsParams) => {
  return [`/user/units/${address}`, ...(params ? [params] : [])] as const;
};

export const getGETUserUserUnitsQueryOptions = <
  TData = Awaited<ReturnType<typeof gETUserUserUnits>>,
  TError = APIErrorResponse,
>(
  address: string,
  params: GETUserUserUnitsParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETUserUserUnits>>, TError, TData> },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETUserUserUnitsQueryKey(address, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETUserUserUnits>>> = ({ signal }) =>
    gETUserUserUnits(address, params, signal);

  return { queryKey, queryFn, enabled: !!address, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETUserUserUnits>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETUserUserUnitsQueryResult = NonNullable<Awaited<ReturnType<typeof gETUserUserUnits>>>;
export type GETUserUserUnitsQueryError = APIErrorResponse;

export const useGETUserUserUnits = <TData = Awaited<ReturnType<typeof gETUserUserUnits>>, TError = APIErrorResponse>(
  address: string,
  params: GETUserUserUnitsParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETUserUserUnits>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETUserUserUnitsQueryOptions(address, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Returns information about the worker service status and registered tasks.

 * @summary Get worker status

 */
export const gETWorkersGetWorkerStatus = (signal?: AbortSignal) => {
  return customHttpClient<GETWorkersGetWorkerStatus200>({ url: `/workers/status`, method: "GET", signal });
};

export const getGETWorkersGetWorkerStatusQueryKey = () => {
  return [`/workers/status`] as const;
};

export const getGETWorkersGetWorkerStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof gETWorkersGetWorkerStatus>>,
  TError = APIErrorResponse,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof gETWorkersGetWorkerStatus>>, TError, TData>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETWorkersGetWorkerStatusQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETWorkersGetWorkerStatus>>> = ({ signal }) =>
    gETWorkersGetWorkerStatus(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETWorkersGetWorkerStatus>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETWorkersGetWorkerStatusQueryResult = NonNullable<Awaited<ReturnType<typeof gETWorkersGetWorkerStatus>>>;
export type GETWorkersGetWorkerStatusQueryError = APIErrorResponse;

/**
 * @summary Get worker status

 */
export const useGETWorkersGetWorkerStatus = <
  TData = Awaited<ReturnType<typeof gETWorkersGetWorkerStatus>>,
  TError = APIErrorResponse,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof gETWorkersGetWorkerStatus>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETWorkersGetWorkerStatusQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

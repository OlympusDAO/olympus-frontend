/**
 * Generated by orval v6.23.0 ðŸº
 * Do not edit manually.
 * Olympus Units API
 * # Olympus Units API

A comprehensive API for managing the Olympus Units rewards system, including:

- **User Management**: User profiles, referral tracking, and authentication
- **Units System**: Seasonal units allocation, epochs, and units history
- **Authentication**: Secure Sign-In with Ethereum (SIWE) support

## Authentication

Most endpoints require JWT authentication. To authenticate:

1. Request a nonce from `/auth/nonce`
2. Sign the message with your Ethereum wallet
3. Submit the signature to `/auth/login` to receive a JWT token
4. Include the JWT token in the `Authorization` header for subsequent requests

## Servers

- **Production**: https://api.olympusdao.finance
- **Staging**: https://dev-olympus-api.callisto.finance
 * OpenAPI spec version: 1.0.0
 */
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";
import { useMutation, useQuery } from "@tanstack/react-query";
import { customHttpClient } from "src/views/Rewards/hooks/customHttpClient";
export type GETWorkersGetWorkerStatus200 = {
  running: boolean;
  tasks: string[];
};

export type GETUsersUserUnits200 = {
  units: UsersUserUnitsSummary;
};

export type GETUsersUserUnitsParams = {
  chainId: LibChainId;
};

export type GETUsersGetProfile200 = {
  createdAt: string;
  discordProfile?: string;
  id: number;
  referralCode?: string;
  userAddress: string;
  walletAddress?: string;
  xProfile?: string;
};

export type GETUsersLeaderboard200 = {
  asOfDate: string;
  chainId: LibChainId;
  comparisonDate: string;
  entries: UsersLeaderboardEntry[];
  total: number;
};

export type GETUsersLeaderboardParams = {
  chainId: LibChainId;
  limit?: number;
  offset?: number;
  daysAgo?: number;
  userAddress?: string;
};

export type GETUsersUserHistory200 = {
  rewards: UsersUserEpochRewardsSummary;
};

export type GETUsersUserHistoryParams = {
  chainId: LibChainId;
};

export type GETRewardsSeasonById200 = {
  season: RewardsSeason;
};

export type GETRewardsSeasonByIdParams = {
  chainId: LibChainId;
};

export type GETRewardsSeasonActive200 = {
  season: RewardsSeasonWithStats;
};

export type GETRewardsSeasonActiveParams = {
  chainId: LibChainId;
};

export type GETRewardsSeasons200 = {
  seasons: RewardsSeason[];
};

export type GETRewardsSeasonsParams = {
  chainId: LibChainId;
  sort?: RewardsSortOrder;
};

export type GETRewardsCurrentEpoch200 = {
  endTimestamp: number;
  epochId: number;
  rewardsPercent: number;
  seasonId: number;
  startTimestamp: number;
  totalUnits: string;
};

export type GETRewardsCurrentEpochParams = {
  chainId: LibChainId;
};

export type GETReadyReady200 = {
  service: string;
  status: string;
  timestamp: string;
};

export type GETAuthVerify200 = {
  address: string;
  authenticated: boolean;
};

export type POSTAuthGetNonce200SiweMessage = {
  address: string;
  chainId: LibChainId;
  domain: string;
  expirationTime: string;
  issuedAt: string;
  nonce: string;
  uri: string;
  version: string;
};

export type POSTAuthGetNonce200 = {
  message: string;
  nonce: string;
  siweMessage?: POSTAuthGetNonce200SiweMessage;
};

export type POSTAuthGetNonceBody = {
  address: string;
  chainId?: LibChainId;
  domain?: string;
  uri?: string;
};

export type POSTAuthLogin200 = {
  address: string;
  expiresIn: string;
  token: string;
};

export type POSTAuthLoginBody = {
  address: string;
  message: string;
  signature: string;
};

export type GETAdminMultisigMembers200 = {
  chainId: LibChainId;
  owners: string[];
  safeAddress: string;
  threshold: number;
};

export type GETAdminMultisigMembersParams = {
  chainId: LibChainId;
  safeAddress: string;
};

export type POSTAdminProposeEpochTransaction200 = {
  merkleRoot: string;
  message: string;
  safeTxHash?: string;
  safeUrl?: string;
  startTimestamp: number;
  status: AdminProposalStatus;
  success: boolean;
  transaction: AdminTransactionDetails;
};

export type POSTAdminProposeEpochTransactionBody = {
  asset?: string;
  callerAddress: string;
  chainId: LibChainId;
  rewardDistributorAddress: string;
  safeAddress: string;
};

export type GETAdminEpochDetails200 = {
  assets: AdminAssetBreakdown[];
  chainId: LibChainId;
  endTimestamp: number;
  epochId: number;
  merkleRoot: string;
  rewardsPercent: number;
  seasonId: number;
  startTimestamp: number;
  totalRewardsDistributed: string;
  totalUnits: string;
  totalYield: string;
  userCount: number;
  users: AdminUserRewardEntry[];
};

export type GETAdminEpochDetailsParams = {
  chainId: LibChainId;
  asset?: string;
};

export type GETAdminPendingEpochs200 = {
  chainId: LibChainId;
  epochs: AdminPendingEpoch[];
};

export type GETAdminPendingEpochsParams = {
  chainId: LibChainId;
  safeAddress: string;
  rewardDistributorAddress: string;
};

/**
 * Error details
 */
export type APIErrorResponseDetails = { [key: string]: any };

export type APIErrorResponse = {
  /** Error code */
  code?: string;
  /** Error details */
  details?: APIErrorResponseDetails;
  /** Error message */
  message?: string;
};

export type UsersUserUnitsSummaryLatestDepositAmount = string | boolean | null | null;

export type UsersUserEpochRewardsEntry = {
  asset: string;
  endDate: number;
  epochId: number;
  epochYield: string;
  merkleLeaf: string;
  merkleProof: string[];
  rewardAmount: string;
  seasonRewardPercent: string;
  startDate: number;
  totalUnits: string;
  updatedAt: string;
};

export type UsersUserEpochRewardsSummary = {
  chainId: LibChainId;
  entries: UsersUserEpochRewardsEntry[];
  totalRewardAmount: string;
  totalUnits: string;
  userAddress: string;
};

export type UsersUserDailyUnitsEntrySeasonId = number | boolean | null | null;

export type UsersUserDailyUnitsEntry = {
  calculatedAt: string;
  depositAmount: string;
  seasonId: UsersUserDailyUnitsEntrySeasonId;
  units: string;
};

export type UsersUserUnitsSummary = {
  address: string;
  chainId: LibChainId;
  entries: UsersUserDailyUnitsEntry[];
  latestDepositAmount: UsersUserUnitsSummaryLatestDepositAmount;
  totalUnits: string;
};

export type UsersLeaderboardEntryPositionDirection =
  (typeof UsersLeaderboardEntryPositionDirection)[keyof typeof UsersLeaderboardEntryPositionDirection];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UsersLeaderboardEntryPositionDirection = {
  up: "up",
  down: "down",
  none: "none",
  new: "new",
} as const;

export type UsersLeaderboardEntry = {
  address: string;
  positionChange: number;
  positionDirection: UsersLeaderboardEntryPositionDirection;
  rank: number;
  totalUnits: string;
};

export type RewardsSortOrder = (typeof RewardsSortOrder)[keyof typeof RewardsSortOrder];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RewardsSortOrder = {
  ASC: "ASC",
  DESC: "DESC",
} as const;

export type RewardsSeasonWithStatsEndDate = string | boolean | null | null;

export type RewardsSeasonWithStats = {
  chain_id: number;
  created_at: string;
  currentWeekTotalUnits: string;
  end_date: RewardsSeasonWithStatsEndDate;
  epoch_days: number;
  id: number;
  rewards_percent: number;
  start_date: string;
  units_base_rate: number;
};

export type RewardsSeasonEndDate = string | boolean | null | null;

export type RewardsSeason = {
  chain_id: number;
  created_at: string;
  end_date: RewardsSeasonEndDate;
  epoch_days: number;
  id: number;
  rewards_percent: number;
  start_date: string;
  units_base_rate: number;
};

export type LibChainId = (typeof LibChainId)[keyof typeof LibChainId];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LibChainId = {
  NUMBER_1: 1,
  NUMBER_11155111: 11155111,
} as const;

export type AdminUserRewardEntry = {
  address: string;
  asset: string;
  merkleLeaf: string;
  rewardAmount: string;
  share: number;
  totalUnits: string;
};

export type AdminTransactionDetails = {
  data: string;
  operation: number;
  to: string;
  value: string;
};

export type AdminProposalStatus = (typeof AdminProposalStatus)[keyof typeof AdminProposalStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AdminProposalStatus = {
  CREATED: "CREATED",
  ALREADY_PENDING: "ALREADY_PENDING",
  ALREADY_EXECUTED: "ALREADY_EXECUTED",
} as const;

export type AdminEpochStatus = (typeof AdminEpochStatus)[keyof typeof AdminEpochStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AdminEpochStatus = {
  NOT_SUBMITTED: "NOT_SUBMITTED",
  PENDING_SIGNATURES: "PENDING_SIGNATURES",
  EXECUTED: "EXECUTED",
} as const;

export type AdminPendingEpoch = {
  assets: string[];
  endTimestamp: number;
  epochId: number;
  merkleRoot: string;
  safeTxHash?: string;
  safeUrl?: string;
  startTimestamp: number;
  status: AdminEpochStatus;
  totalRewardsDistributed: string;
  totalUnits: string;
  userCount: number;
};

export type AdminAssetBreakdown = {
  address: string;
  rewardsDistributed: string;
  yieldAmount: string;
};

/**
 * @summary Serve Swagger UI using Encore's raw endpoint

 */
export const gETDocsSwaggerUI = (signal?: AbortSignal) => {
  return customHttpClient<void>({ url: `/`, method: "GET", signal });
};

export const getGETDocsSwaggerUIQueryKey = () => {
  return [`/`] as const;
};

export const getGETDocsSwaggerUIQueryOptions = <
  TData = Awaited<ReturnType<typeof gETDocsSwaggerUI>>,
  TError = APIErrorResponse,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof gETDocsSwaggerUI>>, TError, TData>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETDocsSwaggerUIQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETDocsSwaggerUI>>> = ({ signal }) => gETDocsSwaggerUI(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETDocsSwaggerUI>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETDocsSwaggerUIQueryResult = NonNullable<Awaited<ReturnType<typeof gETDocsSwaggerUI>>>;
export type GETDocsSwaggerUIQueryError = APIErrorResponse;

/**
 * @summary Serve Swagger UI using Encore's raw endpoint

 */
export const useGETDocsSwaggerUI = <
  TData = Awaited<ReturnType<typeof gETDocsSwaggerUI>>,
  TError = APIErrorResponse,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof gETDocsSwaggerUI>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETDocsSwaggerUIQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Returns a list of epochs with computed rewards and their Safe submission status. Each epoch includes: - Date range and merkle root - Total rewards and user counts - Submission status (NOT\_SUBMITTED, PENDING\_SIGNATURES, or EXECUTED)

@param chainId - Blockchain chain ID (e.g., 11155111 for Sepolia) @param safeAddress - Gnosis Safe multisig address @param rewardDistributorAddress - RewardDistributor contract address @returns PendingEpochsResponse with epochs array

@example GET /admin/epochs/pending?chainId=11155111&safeAddress=0x...&rewardDistributorAddress=0x...

Response: { "epochs": \[ { "startTimestamp": 1732406400, "endTimestamp": 1732665599, "merkleRoot": "0x...", "totalRewardsDistributed": "1000000000000000000", "totalUnits": "5000", "userCount": 10, "assets": \["0x..."], "status": "NOT\_SUBMITTED" } ], "chainId": 11155111 }

 * @summary Get pending epochs requiring merkle root submission

 */
export const gETAdminPendingEpochs = (params: GETAdminPendingEpochsParams, signal?: AbortSignal) => {
  return customHttpClient<GETAdminPendingEpochs200>({ url: `/admin/epochs/pending`, method: "GET", params, signal });
};

export const getGETAdminPendingEpochsQueryKey = (params: GETAdminPendingEpochsParams) => {
  return [`/admin/epochs/pending`, ...(params ? [params] : [])] as const;
};

export const getGETAdminPendingEpochsQueryOptions = <
  TData = Awaited<ReturnType<typeof gETAdminPendingEpochs>>,
  TError = APIErrorResponse,
>(
  params: GETAdminPendingEpochsParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETAdminPendingEpochs>>, TError, TData> },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETAdminPendingEpochsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETAdminPendingEpochs>>> = ({ signal }) =>
    gETAdminPendingEpochs(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETAdminPendingEpochs>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETAdminPendingEpochsQueryResult = NonNullable<Awaited<ReturnType<typeof gETAdminPendingEpochs>>>;
export type GETAdminPendingEpochsQueryError = APIErrorResponse;

/**
 * @summary Get pending epochs requiring merkle root submission

 */
export const useGETAdminPendingEpochs = <
  TData = Awaited<ReturnType<typeof gETAdminPendingEpochs>>,
  TError = APIErrorResponse,
>(
  params: GETAdminPendingEpochsParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETAdminPendingEpochs>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETAdminPendingEpochsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Returns comprehensive epoch data for the proposal review page including: - Epoch timestamps and season info - Total units, yield, and rewards distributed - Per-asset breakdown - User table with addresses, units, and rewards

@param startTimestamp - Epoch start timestamp in Unix seconds (path parameter) @param chainId - Blockchain chain ID (e.g., 11155111 for Sepolia) @param asset - Optional asset address to filter results @returns EpochDetailsResponse with full epoch breakdown

@example GET /admin/epochs/1732406400?chainId=11155111

Response: { "startTimestamp": 1732406400, "endTimestamp": 1732665599, "seasonId": 2, "rewardsPercent": 50, "totalUnits": "5000", "totalYield": "2000000000000000000", "totalRewardsDistributed": "1000000000000000000", "merkleRoot": "0x...", "assets": \[...], "users": \[...], "userCount": 10, "chainId": 11155111 }

 * @summary Get detailed epoch information

 */
export const gETAdminEpochDetails = (
  startTimestamp: number,
  params: GETAdminEpochDetailsParams,
  signal?: AbortSignal,
) => {
  return customHttpClient<GETAdminEpochDetails200>({
    url: `/admin/epochs/${startTimestamp}`,
    method: "GET",
    params,
    signal,
  });
};

export const getGETAdminEpochDetailsQueryKey = (startTimestamp: number, params: GETAdminEpochDetailsParams) => {
  return [`/admin/epochs/${startTimestamp}`, ...(params ? [params] : [])] as const;
};

export const getGETAdminEpochDetailsQueryOptions = <
  TData = Awaited<ReturnType<typeof gETAdminEpochDetails>>,
  TError = APIErrorResponse,
>(
  startTimestamp: number,
  params: GETAdminEpochDetailsParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETAdminEpochDetails>>, TError, TData> },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETAdminEpochDetailsQueryKey(startTimestamp, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETAdminEpochDetails>>> = ({ signal }) =>
    gETAdminEpochDetails(startTimestamp, params, signal);

  return { queryKey, queryFn, enabled: !!startTimestamp, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETAdminEpochDetails>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETAdminEpochDetailsQueryResult = NonNullable<Awaited<ReturnType<typeof gETAdminEpochDetails>>>;
export type GETAdminEpochDetailsQueryError = APIErrorResponse;

/**
 * @summary Get detailed epoch information

 */
export const useGETAdminEpochDetails = <
  TData = Awaited<ReturnType<typeof gETAdminEpochDetails>>,
  TError = APIErrorResponse,
>(
  startTimestamp: number,
  params: GETAdminEpochDetailsParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETAdminEpochDetails>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETAdminEpochDetailsQueryOptions(startTimestamp, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * This endpoint: 1. Verifies the caller is a Safe owner 2. Checks the Safe has ROLE\_MERKLE\_UPDATER permission 3. Checks for existing transactions with the same merkle root 4. Returns encoded transaction data for the frontend to sign/propose

The frontend should use the returned transaction details to: - Create a Safe transaction using Safe SDK - Sign and propose the transaction to the Safe Transaction Service

@param startTimestamp - Epoch start timestamp in Unix seconds (path parameter) @param chainId - Blockchain chain ID (e.g., 11155111 for Sepolia) @param safeAddress - Gnosis Safe multisig address @param rewardDistributorAddress - RewardDistributor contract address @param callerAddress - Connected wallet address from RainbowKit @param asset - Optional asset address for specific asset submission @returns ProposeTransactionResponse with transaction details

@example POST /admin/epochs/1732406400/propose Body: { "chainId": 11155111, "safeAddress": "0x...", "rewardDistributorAddress": "0x...", "callerAddress": "0x..." }

Response: { "success": true, "merkleRoot": "0x...", "startTimestamp": 1732406400, "status": "CREATED", "message": "Transaction data prepared...", "transaction": { "to": "0x...", "data": "0x...", "value": "0", "operation": 0 } }

 * @summary Create a Safe transaction proposal for merkle root submission

 */
export const pOSTAdminProposeEpochTransaction = (
  startTimestamp: number,
  pOSTAdminProposeEpochTransactionBody: POSTAdminProposeEpochTransactionBody,
) => {
  return customHttpClient<POSTAdminProposeEpochTransaction200>({
    url: `/admin/epochs/${startTimestamp}/propose`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: pOSTAdminProposeEpochTransactionBody,
  });
};

export const getPOSTAdminProposeEpochTransactionMutationOptions = <
  TError = APIErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof pOSTAdminProposeEpochTransaction>>,
    TError,
    { startTimestamp: number; data: POSTAdminProposeEpochTransactionBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof pOSTAdminProposeEpochTransaction>>,
  TError,
  { startTimestamp: number; data: POSTAdminProposeEpochTransactionBody },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof pOSTAdminProposeEpochTransaction>>,
    { startTimestamp: number; data: POSTAdminProposeEpochTransactionBody }
  > = props => {
    const { startTimestamp, data } = props ?? {};

    return pOSTAdminProposeEpochTransaction(startTimestamp, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type POSTAdminProposeEpochTransactionMutationResult = NonNullable<
  Awaited<ReturnType<typeof pOSTAdminProposeEpochTransaction>>
>;
export type POSTAdminProposeEpochTransactionMutationBody = POSTAdminProposeEpochTransactionBody;
export type POSTAdminProposeEpochTransactionMutationError = APIErrorResponse;

/**
 * @summary Create a Safe transaction proposal for merkle root submission

 */
export const usePOSTAdminProposeEpochTransaction = <TError = APIErrorResponse, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof pOSTAdminProposeEpochTransaction>>,
    TError,
    { startTimestamp: number; data: POSTAdminProposeEpochTransactionBody },
    TContext
  >;
}) => {
  const mutationOptions = getPOSTAdminProposeEpochTransactionMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Returns the list of owner addresses and signature threshold for a Gnosis Safe. This endpoint is public as Safe ownership data is on-chain and publicly available.

@param chainId - Blockchain chain ID (e.g., 11155111 for Sepolia) @param safeAddress - Gnosis Safe multisig address @returns MultisigMembersResponse with owners array and threshold

@example GET /admin/multisig/members?chainId=11155111&safeAddress=0x...

Response: { "safeAddress": "0x...", "owners": \["0x...", "0x...", "0x..."], "threshold": 2, "chainId": 11155111 }

 * @summary Get multisig members (owners) for a Safe

 */
export const gETAdminMultisigMembers = (params: GETAdminMultisigMembersParams, signal?: AbortSignal) => {
  return customHttpClient<GETAdminMultisigMembers200>({
    url: `/admin/multisig/members`,
    method: "GET",
    params,
    signal,
  });
};

export const getGETAdminMultisigMembersQueryKey = (params: GETAdminMultisigMembersParams) => {
  return [`/admin/multisig/members`, ...(params ? [params] : [])] as const;
};

export const getGETAdminMultisigMembersQueryOptions = <
  TData = Awaited<ReturnType<typeof gETAdminMultisigMembers>>,
  TError = APIErrorResponse,
>(
  params: GETAdminMultisigMembersParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETAdminMultisigMembers>>, TError, TData> },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETAdminMultisigMembersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETAdminMultisigMembers>>> = ({ signal }) =>
    gETAdminMultisigMembers(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETAdminMultisigMembers>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETAdminMultisigMembersQueryResult = NonNullable<Awaited<ReturnType<typeof gETAdminMultisigMembers>>>;
export type GETAdminMultisigMembersQueryError = APIErrorResponse;

/**
 * @summary Get multisig members (owners) for a Safe

 */
export const useGETAdminMultisigMembers = <
  TData = Awaited<ReturnType<typeof gETAdminMultisigMembers>>,
  TError = APIErrorResponse,
>(
  params: GETAdminMultisigMembersParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETAdminMultisigMembers>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETAdminMultisigMembersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * This endpoint verifies the user's EIP-4361 (SIWE) signature and returns a JWT token that can be used for subsequent authenticated requests.

The token is valid for 7 days by default.

 * @summary Login endpoint - Exchange signature for JWT token

 */
export const pOSTAuthLogin = (pOSTAuthLoginBody: POSTAuthLoginBody) => {
  return customHttpClient<POSTAuthLogin200>({
    url: `/auth/login`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: pOSTAuthLoginBody,
  });
};

export const getPOSTAuthLoginMutationOptions = <TError = APIErrorResponse, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof pOSTAuthLogin>>,
    TError,
    { data: POSTAuthLoginBody },
    TContext
  >;
}): UseMutationOptions<Awaited<ReturnType<typeof pOSTAuthLogin>>, TError, { data: POSTAuthLoginBody }, TContext> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof pOSTAuthLogin>>,
    { data: POSTAuthLoginBody }
  > = props => {
    const { data } = props ?? {};

    return pOSTAuthLogin(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type POSTAuthLoginMutationResult = NonNullable<Awaited<ReturnType<typeof pOSTAuthLogin>>>;
export type POSTAuthLoginMutationBody = POSTAuthLoginBody;
export type POSTAuthLoginMutationError = APIErrorResponse;

/**
 * @summary Login endpoint - Exchange signature for JWT token

 */
export const usePOSTAuthLogin = <TError = APIErrorResponse, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof pOSTAuthLogin>>,
    TError,
    { data: POSTAuthLoginBody },
    TContext
  >;
}) => {
  const mutationOptions = getPOSTAuthLoginMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * This endpoint generates an EIP-4361 (Sign-In with Ethereum) compliant message that the user must sign with their wallet.

 * @summary Generate a nonce for the user to sign

 */
export const pOSTAuthGetNonce = (pOSTAuthGetNonceBody: POSTAuthGetNonceBody) => {
  return customHttpClient<POSTAuthGetNonce200>({
    url: `/auth/nonce`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: pOSTAuthGetNonceBody,
  });
};

export const getPOSTAuthGetNonceMutationOptions = <TError = APIErrorResponse, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof pOSTAuthGetNonce>>,
    TError,
    { data: POSTAuthGetNonceBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof pOSTAuthGetNonce>>,
  TError,
  { data: POSTAuthGetNonceBody },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof pOSTAuthGetNonce>>,
    { data: POSTAuthGetNonceBody }
  > = props => {
    const { data } = props ?? {};

    return pOSTAuthGetNonce(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type POSTAuthGetNonceMutationResult = NonNullable<Awaited<ReturnType<typeof pOSTAuthGetNonce>>>;
export type POSTAuthGetNonceMutationBody = POSTAuthGetNonceBody;
export type POSTAuthGetNonceMutationError = APIErrorResponse;

/**
 * @summary Generate a nonce for the user to sign

 */
export const usePOSTAuthGetNonce = <TError = APIErrorResponse, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof pOSTAuthGetNonce>>,
    TError,
    { data: POSTAuthGetNonceBody },
    TContext
  >;
}) => {
  const mutationOptions = getPOSTAuthGetNonceMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * This is a protected endpoint that requires authentication. It demonstrates how to use getAuthData() to access user data.

 * @summary Verify the user's authentication

 */
export const gETAuthVerify = (signal?: AbortSignal) => {
  return customHttpClient<GETAuthVerify200>({ url: `/auth/verify`, method: "GET", signal });
};

export const getGETAuthVerifyQueryKey = () => {
  return [`/auth/verify`] as const;
};

export const getGETAuthVerifyQueryOptions = <
  TData = Awaited<ReturnType<typeof gETAuthVerify>>,
  TError = APIErrorResponse,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof gETAuthVerify>>, TError, TData>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETAuthVerifyQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETAuthVerify>>> = ({ signal }) => gETAuthVerify(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETAuthVerify>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETAuthVerifyQueryResult = NonNullable<Awaited<ReturnType<typeof gETAuthVerify>>>;
export type GETAuthVerifyQueryError = APIErrorResponse;

/**
 * @summary Verify the user's authentication

 */
export const useGETAuthVerify = <
  TData = Awaited<ReturnType<typeof gETAuthVerify>>,
  TError = APIErrorResponse,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof gETAuthVerify>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETAuthVerifyQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary JSON endpoint for the OpenAPI spec

 */
export const gETDocsOpenapiJson = (signal?: AbortSignal) => {
  return customHttpClient<void>({ url: `/openapi.json`, method: "GET", signal });
};

export const getGETDocsOpenapiJsonQueryKey = () => {
  return [`/openapi.json`] as const;
};

export const getGETDocsOpenapiJsonQueryOptions = <
  TData = Awaited<ReturnType<typeof gETDocsOpenapiJson>>,
  TError = APIErrorResponse,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof gETDocsOpenapiJson>>, TError, TData>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETDocsOpenapiJsonQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETDocsOpenapiJson>>> = ({ signal }) =>
    gETDocsOpenapiJson(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETDocsOpenapiJson>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETDocsOpenapiJsonQueryResult = NonNullable<Awaited<ReturnType<typeof gETDocsOpenapiJson>>>;
export type GETDocsOpenapiJsonQueryError = APIErrorResponse;

/**
 * @summary JSON endpoint for the OpenAPI spec

 */
export const useGETDocsOpenapiJson = <
  TData = Awaited<ReturnType<typeof gETDocsOpenapiJson>>,
  TError = APIErrorResponse,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof gETDocsOpenapiJson>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETDocsOpenapiJsonQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const gETReadyReady = (signal?: AbortSignal) => {
  return customHttpClient<GETReadyReady200>({ url: `/ready`, method: "GET", signal });
};

export const getGETReadyReadyQueryKey = () => {
  return [`/ready`] as const;
};

export const getGETReadyReadyQueryOptions = <
  TData = Awaited<ReturnType<typeof gETReadyReady>>,
  TError = APIErrorResponse,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof gETReadyReady>>, TError, TData>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETReadyReadyQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETReadyReady>>> = ({ signal }) => gETReadyReady(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETReadyReady>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETReadyReadyQueryResult = NonNullable<Awaited<ReturnType<typeof gETReadyReady>>>;
export type GETReadyReadyQueryError = APIErrorResponse;

export const useGETReadyReady = <
  TData = Awaited<ReturnType<typeof gETReadyReady>>,
  TError = APIErrorResponse,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof gETReadyReady>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETReadyReadyQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Returns the current epoch boundaries and accumulated units for the ongoing epoch. The epoch boundaries are calculated from the active season's configuration.

@param chainId - Blockchain chain ID (e.g., 11155111 for Sepolia) @returns Current epoch details including timestamps, season info, and accumulated units

@example GET /rewards/epochs/current?chainId=11155111

Response: { "epochId": 3, "startTimestamp": 1733702400, "endTimestamp": 1734307199, "seasonId": 1, "rewardsPercent": 50, "totalUnits": "1500000" }

 * @summary Get the current ongoing epoch details

 */
export const gETRewardsCurrentEpoch = (params: GETRewardsCurrentEpochParams, signal?: AbortSignal) => {
  return customHttpClient<GETRewardsCurrentEpoch200>({ url: `/rewards/epochs/current`, method: "GET", params, signal });
};

export const getGETRewardsCurrentEpochQueryKey = (params: GETRewardsCurrentEpochParams) => {
  return [`/rewards/epochs/current`, ...(params ? [params] : [])] as const;
};

export const getGETRewardsCurrentEpochQueryOptions = <
  TData = Awaited<ReturnType<typeof gETRewardsCurrentEpoch>>,
  TError = APIErrorResponse,
>(
  params: GETRewardsCurrentEpochParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETRewardsCurrentEpoch>>, TError, TData> },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETRewardsCurrentEpochQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETRewardsCurrentEpoch>>> = ({ signal }) =>
    gETRewardsCurrentEpoch(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETRewardsCurrentEpoch>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETRewardsCurrentEpochQueryResult = NonNullable<Awaited<ReturnType<typeof gETRewardsCurrentEpoch>>>;
export type GETRewardsCurrentEpochQueryError = APIErrorResponse;

/**
 * @summary Get the current ongoing epoch details

 */
export const useGETRewardsCurrentEpoch = <
  TData = Awaited<ReturnType<typeof gETRewardsCurrentEpoch>>,
  TError = APIErrorResponse,
>(
  params: GETRewardsCurrentEpochParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETRewardsCurrentEpoch>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETRewardsCurrentEpochQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @param chainId - The blockchain chain ID (e.g., 11155111) @param sort - Sort order by season ID (default: 'asc') @returns List of all seasons for the chain

 * @summary Get all seasons for a specific chain

 */
export const gETRewardsSeasons = (params: GETRewardsSeasonsParams, signal?: AbortSignal) => {
  return customHttpClient<GETRewardsSeasons200>({ url: `/rewards/seasons`, method: "GET", params, signal });
};

export const getGETRewardsSeasonsQueryKey = (params: GETRewardsSeasonsParams) => {
  return [`/rewards/seasons`, ...(params ? [params] : [])] as const;
};

export const getGETRewardsSeasonsQueryOptions = <
  TData = Awaited<ReturnType<typeof gETRewardsSeasons>>,
  TError = APIErrorResponse,
>(
  params: GETRewardsSeasonsParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETRewardsSeasons>>, TError, TData> },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETRewardsSeasonsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETRewardsSeasons>>> = ({ signal }) =>
    gETRewardsSeasons(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETRewardsSeasons>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETRewardsSeasonsQueryResult = NonNullable<Awaited<ReturnType<typeof gETRewardsSeasons>>>;
export type GETRewardsSeasonsQueryError = APIErrorResponse;

/**
 * @summary Get all seasons for a specific chain

 */
export const useGETRewardsSeasons = <TData = Awaited<ReturnType<typeof gETRewardsSeasons>>, TError = APIErrorResponse>(
  params: GETRewardsSeasonsParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETRewardsSeasons>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETRewardsSeasonsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @param chainId - The blockchain chain ID (e.g., 11155111) @returns The active season with its configuration and current week total units

 * @summary Get the currently active season for a specific chain

 */
export const gETRewardsSeasonActive = (params: GETRewardsSeasonActiveParams, signal?: AbortSignal) => {
  return customHttpClient<GETRewardsSeasonActive200>({ url: `/rewards/seasons/active`, method: "GET", params, signal });
};

export const getGETRewardsSeasonActiveQueryKey = (params: GETRewardsSeasonActiveParams) => {
  return [`/rewards/seasons/active`, ...(params ? [params] : [])] as const;
};

export const getGETRewardsSeasonActiveQueryOptions = <
  TData = Awaited<ReturnType<typeof gETRewardsSeasonActive>>,
  TError = APIErrorResponse,
>(
  params: GETRewardsSeasonActiveParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETRewardsSeasonActive>>, TError, TData> },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETRewardsSeasonActiveQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETRewardsSeasonActive>>> = ({ signal }) =>
    gETRewardsSeasonActive(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETRewardsSeasonActive>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETRewardsSeasonActiveQueryResult = NonNullable<Awaited<ReturnType<typeof gETRewardsSeasonActive>>>;
export type GETRewardsSeasonActiveQueryError = APIErrorResponse;

/**
 * @summary Get the currently active season for a specific chain

 */
export const useGETRewardsSeasonActive = <
  TData = Awaited<ReturnType<typeof gETRewardsSeasonActive>>,
  TError = APIErrorResponse,
>(
  params: GETRewardsSeasonActiveParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETRewardsSeasonActive>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETRewardsSeasonActiveQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @param id - The season ID @param chainId - The blockchain chain ID (e.g., 11155111) @returns The season object

 * @summary Get a season by ID for a specific chain

 */
export const gETRewardsSeasonById = (id: number, params: GETRewardsSeasonByIdParams, signal?: AbortSignal) => {
  return customHttpClient<GETRewardsSeasonById200>({ url: `/rewards/seasons/${id}`, method: "GET", params, signal });
};

export const getGETRewardsSeasonByIdQueryKey = (id: number, params: GETRewardsSeasonByIdParams) => {
  return [`/rewards/seasons/${id}`, ...(params ? [params] : [])] as const;
};

export const getGETRewardsSeasonByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof gETRewardsSeasonById>>,
  TError = APIErrorResponse,
>(
  id: number,
  params: GETRewardsSeasonByIdParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETRewardsSeasonById>>, TError, TData> },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETRewardsSeasonByIdQueryKey(id, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETRewardsSeasonById>>> = ({ signal }) =>
    gETRewardsSeasonById(id, params, signal);

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETRewardsSeasonById>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETRewardsSeasonByIdQueryResult = NonNullable<Awaited<ReturnType<typeof gETRewardsSeasonById>>>;
export type GETRewardsSeasonByIdQueryError = APIErrorResponse;

/**
 * @summary Get a season by ID for a specific chain

 */
export const useGETRewardsSeasonById = <
  TData = Awaited<ReturnType<typeof gETRewardsSeasonById>>,
  TError = APIErrorResponse,
>(
  id: number,
  params: GETRewardsSeasonByIdParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETRewardsSeasonById>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETRewardsSeasonByIdQueryOptions(id, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const gETUsersUserHistory = (address: string, params: GETUsersUserHistoryParams, signal?: AbortSignal) => {
  return customHttpClient<GETUsersUserHistory200>({ url: `/users/history/${address}`, method: "GET", params, signal });
};

export const getGETUsersUserHistoryQueryKey = (address: string, params: GETUsersUserHistoryParams) => {
  return [`/users/history/${address}`, ...(params ? [params] : [])] as const;
};

export const getGETUsersUserHistoryQueryOptions = <
  TData = Awaited<ReturnType<typeof gETUsersUserHistory>>,
  TError = APIErrorResponse,
>(
  address: string,
  params: GETUsersUserHistoryParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETUsersUserHistory>>, TError, TData> },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETUsersUserHistoryQueryKey(address, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETUsersUserHistory>>> = ({ signal }) =>
    gETUsersUserHistory(address, params, signal);

  return { queryKey, queryFn, enabled: !!address, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETUsersUserHistory>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETUsersUserHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof gETUsersUserHistory>>>;
export type GETUsersUserHistoryQueryError = APIErrorResponse;

export const useGETUsersUserHistory = <
  TData = Awaited<ReturnType<typeof gETUsersUserHistory>>,
  TError = APIErrorResponse,
>(
  address: string,
  params: GETUsersUserHistoryParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETUsersUserHistory>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETUsersUserHistoryQueryOptions(address, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const gETUsersLeaderboard = (params: GETUsersLeaderboardParams, signal?: AbortSignal) => {
  return customHttpClient<GETUsersLeaderboard200>({ url: `/users/leaderboard`, method: "GET", params, signal });
};

export const getGETUsersLeaderboardQueryKey = (params: GETUsersLeaderboardParams) => {
  return [`/users/leaderboard`, ...(params ? [params] : [])] as const;
};

export const getGETUsersLeaderboardQueryOptions = <
  TData = Awaited<ReturnType<typeof gETUsersLeaderboard>>,
  TError = APIErrorResponse,
>(
  params: GETUsersLeaderboardParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETUsersLeaderboard>>, TError, TData> },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETUsersLeaderboardQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETUsersLeaderboard>>> = ({ signal }) =>
    gETUsersLeaderboard(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETUsersLeaderboard>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETUsersLeaderboardQueryResult = NonNullable<Awaited<ReturnType<typeof gETUsersLeaderboard>>>;
export type GETUsersLeaderboardQueryError = APIErrorResponse;

export const useGETUsersLeaderboard = <
  TData = Awaited<ReturnType<typeof gETUsersLeaderboard>>,
  TError = APIErrorResponse,
>(
  params: GETUsersLeaderboardParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETUsersLeaderboard>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETUsersLeaderboardQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * This is a protected endpoint that returns the current user's profile.

 * @summary Get the authenticated user's profile

 */
export const gETUsersGetProfile = (signal?: AbortSignal) => {
  return customHttpClient<GETUsersGetProfile200>({ url: `/users/profile`, method: "GET", signal });
};

export const getGETUsersGetProfileQueryKey = () => {
  return [`/users/profile`] as const;
};

export const getGETUsersGetProfileQueryOptions = <
  TData = Awaited<ReturnType<typeof gETUsersGetProfile>>,
  TError = APIErrorResponse,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof gETUsersGetProfile>>, TError, TData>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETUsersGetProfileQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETUsersGetProfile>>> = ({ signal }) =>
    gETUsersGetProfile(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETUsersGetProfile>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETUsersGetProfileQueryResult = NonNullable<Awaited<ReturnType<typeof gETUsersGetProfile>>>;
export type GETUsersGetProfileQueryError = APIErrorResponse;

/**
 * @summary Get the authenticated user's profile

 */
export const useGETUsersGetProfile = <
  TData = Awaited<ReturnType<typeof gETUsersGetProfile>>,
  TError = APIErrorResponse,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof gETUsersGetProfile>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETUsersGetProfileQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const gETUsersUserUnits = (address: string, params: GETUsersUserUnitsParams, signal?: AbortSignal) => {
  return customHttpClient<GETUsersUserUnits200>({ url: `/users/units/${address}`, method: "GET", params, signal });
};

export const getGETUsersUserUnitsQueryKey = (address: string, params: GETUsersUserUnitsParams) => {
  return [`/users/units/${address}`, ...(params ? [params] : [])] as const;
};

export const getGETUsersUserUnitsQueryOptions = <
  TData = Awaited<ReturnType<typeof gETUsersUserUnits>>,
  TError = APIErrorResponse,
>(
  address: string,
  params: GETUsersUserUnitsParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETUsersUserUnits>>, TError, TData> },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETUsersUserUnitsQueryKey(address, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETUsersUserUnits>>> = ({ signal }) =>
    gETUsersUserUnits(address, params, signal);

  return { queryKey, queryFn, enabled: !!address, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETUsersUserUnits>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETUsersUserUnitsQueryResult = NonNullable<Awaited<ReturnType<typeof gETUsersUserUnits>>>;
export type GETUsersUserUnitsQueryError = APIErrorResponse;

export const useGETUsersUserUnits = <TData = Awaited<ReturnType<typeof gETUsersUserUnits>>, TError = APIErrorResponse>(
  address: string,
  params: GETUsersUserUnitsParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof gETUsersUserUnits>>, TError, TData> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETUsersUserUnitsQueryOptions(address, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Returns information about the worker service status and registered tasks.

 * @summary Get worker status

 */
export const gETWorkersGetWorkerStatus = (signal?: AbortSignal) => {
  return customHttpClient<GETWorkersGetWorkerStatus200>({ url: `/workers/status`, method: "GET", signal });
};

export const getGETWorkersGetWorkerStatusQueryKey = () => {
  return [`/workers/status`] as const;
};

export const getGETWorkersGetWorkerStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof gETWorkersGetWorkerStatus>>,
  TError = APIErrorResponse,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof gETWorkersGetWorkerStatus>>, TError, TData>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGETWorkersGetWorkerStatusQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gETWorkersGetWorkerStatus>>> = ({ signal }) =>
    gETWorkersGetWorkerStatus(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gETWorkersGetWorkerStatus>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GETWorkersGetWorkerStatusQueryResult = NonNullable<Awaited<ReturnType<typeof gETWorkersGetWorkerStatus>>>;
export type GETWorkersGetWorkerStatusQueryError = APIErrorResponse;

/**
 * @summary Get worker status

 */
export const useGETWorkersGetWorkerStatus = <
  TData = Awaited<ReturnType<typeof gETWorkersGetWorkerStatus>>,
  TError = APIErrorResponse,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof gETWorkersGetWorkerStatus>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGETWorkersGetWorkerStatusQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};
